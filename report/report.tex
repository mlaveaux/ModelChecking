\documentclass[10pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage{pgf}
\usepackage{pgfplots}
\usepackage{comment}

\title{Implementation and evaluation of model checking using modal mu-calculus}

\author{Olav Bunte (0803961), Maurice Laveaux (0813568),\\ Ziad Ben Snaiba (0748095)}

\date{\today}

\begin{document}
\maketitle

\section{Introduction}
This report elaborates on our work and findings of assignment on, which is split in two parts. The first part of the assignment is to implement two versions of the model checking algorithm for modal mu-calculus: a naive version and the Emerson-Lei version. The second part is to evaluate these two versions using provided testcases supplemented with modal mu-calculus formulas of our own.\\
In section \ref{design} we will explain our design of the algorithm. The testcases and their result when used on the algorithm is shown in section 3. Lastly, we conclude this report in section 4.

\section{Design}\label{design}
In this section the design of our model checking algorithm is given, which we have coded in C++. First we will show the data structure of modal mu-calculus formulas and how they are constructed. Then we elaborate on the design of the solving algorithm divided in what the two versions of the algorithm have in common and what is special to each version.

% data structure of formula, parsing
\subsection{Modal mu-calculus formulas}
Since the modal mu-calculus is defined recursively, we have decided to store mu-calculus formulas the same way. To do so we have implemented a class \texttt{MuFormula}, which represent a subformula of the given mu-calculus formula. This \texttt{MuFormula} can hold up to two pointers two other subformulas, which are its direct subformulas. These subformulas combined by an operation form the \texttt{MuFormula}, as it is defined in the modal mu-calculus grammar. This operation is implemented as the enum \texttt{Op} which can have the following values:
\begin{itemize}
\item FALSE: the value false
\item TRUE: the value true
\item VAR: a variable
\item AND: logical and
\item OR: logical or
\item DIAMOND: the diamond operator
\item BOX: the box operator
\item MU: the least fixed point operator
\item NU: the greatest fixed point operator
\end{itemize}
When $\texttt{Op} \in \{\text{FALSE}, \text{TRUE}, \text{VAR}\}$ no subformula is defined, when $\texttt{Op} \in \{\text{AND}, \text{OR}\}$ both subformulas are defined and else only the first subformula is defined.\\
For the cases $\texttt{Op} \in \{\text{BOX}, \text{DIAMOND}\}$ the \texttt{MuFormula} needs to know the transition label and for the cases $\texttt{Op} \in \{\text{VAR}, \text{MU}, \text{NU}\}$ the \texttt{MuFormula} needs to know the name of the variable. These labels and variable names are stored as a string. Since these cases are distinct, we have decided to store these values in the same string variable, named \texttt{varlabel}, to reduce memory usage.\\
These values are filled for every subformula during the parsing of the file with the mu-calculus formula. This parsing is implemented in the same recursive fashion as in the provided pseudocode \cite{muparse}.


% basis (solve method), what naive and EL have in common
\subsection{Solving algorithm}
As in the slides, the basis of the algorithm is a sequence of conditions, one for each possible \texttt{Op}. If the subformula to be solved has direct subformulas, these are solved first after which the \texttt{Op} is applied to the resultset(s) of states.\\
The naive and the Emerson-Lei versions differ in how they handle the fixed point operators. These differences are explained below.

% what is special to naive
\subsubsection{Naive algorithm}


% what is special to EL
\subsubsection{Emerson-Lei algorithm}


\section{Evaluation}\label{eval}
In this section we will elaborate on the mu-calculus formulas provided and made for the experiments in the second part of the assignment. For each of these formulas it will be explained why this is the correct formula for the given problem and its nesting ($ND$), alternation ($AD$) and dependent alternation depth ($DAD$) will be given.\\
Afterwards the result of our solver will be given for each formula. The performance results for each formula and each corresponding LTS will be shown as well.

\subsection{Performance}

The performance tests were conducted on a EliteBook 8560w running Arch Linux. Its relevant hardware specification are stated below.

\begin{itemize}
	\item Intel Core i7-2720QM Processor (2.20 GHz, 6MB L3 cache, 4 cores/8 threads, 45 W) Up to 3.30 GHz with Intel Turbo Boost Technology.
	
	\item 8GB memory in 2 slotted DDR3 PC3-10600 SDRAM (1,333 MHz) cards.
\end{itemize}

\subsection{Dining philosophers}
The first experiment is the well-known dining philosophers problem. The mu-calculus formulas for this assignment were provided and are elaborated on below. Afterwards the results of this experiment are given.

\subsubsection{Mu-calculus formulas}
\textbf{In every reachable state, someone must start eating}\\
This can be expressed with the formula:\\
{\tt nu X. (([i]X \&\& ([plato]X \&\& [others]X)) \&\& mu Y. ([i]Y \&\& (<plato>true || <others>true)))}\\
The part {\tt nu X. (([i]X \&\& ([plato]X \&\& [others]X)) ..)} iterates over all successor states, getting to each reachable state. The other part states that for each of these states it must hold that within any finite sequence of states of no-one eating ({\tt \&\& mu Y. ([i]Y ..)}) either Plato or another philosopher will be able to eat ({\tt \&\& (<plato>true || <others>true)}).\\
The depths for this formula are: $ND = 2$, $AD = 2$ and $DAD = 1$.
\\\\
\textbf{In every state, reachable by Plato not eating, Plato has the chance to starve}\\
This can be expressed with the formula:\\
{\tt nu X. (([i]X \&\& [others]X) \&\& nu Y. (<i>Y || <others>Y))}\\
The part {\tt nu X. (([i]X \&\& [others]X) ..)} iterates over all successor states as long as Plato does not eat, getting to each reachable state where Plato has not eaten yet. The other part states that for each of these states it must hold that there must exist an infinite sequence of states ({\tt \&\& nu Y.}) where Plato will not eat ({\tt (<i>Y || <others>Y)}).\\
The depths of this formula are: $ND = 2$, $AD = 1$ and $DAD = 1$.
\\\\
\textbf{Invariantly, Plato can eat in some future}\\
This can be expressed with the formula:\\
{\tt nu X. (([i]X \&\& ([plato]X \&\& [others]X)) \&\& mu Y. ((<i>Y || <others>Y) || <plato>true ))}\\
The part {\tt nu X. (([i]X \&\& ([plato]X \&\& [others]X)) ..)} iterates over all successor states, getting to each reachable state. The other part states that from each of these states there must exist a finite sequence of states where Plato does not eat ({\tt \&\& mu Y. ((<i>Y || <others>Y) ..)} after which Plato will be able to eat ({\tt || <plato>true}).\\
The depths of this formula are: $ND = 2$, $AD = 2$ and $DAD = 1$.
\\\\
\textbf{There is a course of events in which Plato infinitely often eats}\\
This can be expressed with the formula:\\
{\tt nu X. mu Y. ((<plato>X || <i>Y) || <others>Y)}\\
The part {\tt mu Y. ((<plato>X || <i>Y) || <others>Y)} states that er must be a finite sequence of states where Plato does not eat, after which Plato will be able to eat. The part {\tt nu X. .. ((<plato>X ..) ..)} states that this sequence must be able to repeat itself infinitely often.\\
The depths of this formula are: $ND = 2$, $AD = 2$ and $DAD = 2$.

\subsubsection{Solver and performance results}

The graph below shows the time in seconds that the program runs using labelled transition systems from two up to 11 dining philosophers. The formulas to be checked are the four formulas explained before. In the graphs show below the blue line is the naive algorithm and red indicates the timing for the improved algorithm.

Invariantly inevitably eat (doesn't hold):

\begin{tikzpicture}
  	\begin{axis}[ 
    	xlabel={Number of philosophers},
    	ylabel={Duration (Seconds)}
  	] 
    \addplot+ [color=blue] coordinates {(2, 0.005) (3, 0.005) (4, 0.006) (5, 0.011) (6, 0.047) (7, 0.174) (8, 1.270) (9, 6.131) (10, 34.391) (11, 144.252)}; 
    
    \addplot+ [color=red] coordinates {(2, 0.002) (3, 0.002) (4, 0.002) (5, 0.005) (6, 0.017) (7, 0.065) (8, 0.333) (9, 1.442) (10, 6.716) (11, 26.529)}; 
  	\end{axis}
\end{tikzpicture}

Invariantly plato starves (doesn't hold):

\begin{tikzpicture}
  	\begin{axis}[ 
    	xlabel={Number of philosophers},
    	ylabel={Duration (Seconds)}
  	] 
    \addplot+ [color=blue] coordinates {(2, 0.003) (3, 0.003) (4, 0.006) (5, 0.023) (6, 0.071) (7, 0.242) (8, 1.225) (9, 5.745) (10, 24.924) (11, 104.356)}; 
    
    \addplot+ [color=red] coordinates {(2, 0.002) (3, 0.003) (4, 0.005) (5, 0.012) (6, 0.029) (7, 0.108) (8, 0.496) (9, 2.435) (10, 10.081) (11, 41.595)}; 
  	\end{axis}
\end{tikzpicture}

Invariantly plato can eat in the future (doesn't hold):

\begin{tikzpicture}
  	\begin{axis}[ 
    	xlabel={Number of philosophers},
    	ylabel={Duration (Seconds)}
  	] 
    \addplot+ [color=blue] coordinates {(2, 0.002) (3, 0.005) (4, 0.017) (5, 0.060) (6, 0.317) (7, 1.460) (8, 10.281) (9, 53.395) (10, 255.15) (11, 1044.492)}; 
    
    \addplot+ [color=red] coordinates {(2, 0.004) (3, 0.005) (4, 0.009) (5, 0.021) (6, 0.055) (7, 0.202) (8, 1.027) (9, 4.492) (10, 19.628) (11, 77.475)}; 
  	\end{axis}
\end{tikzpicture}

There is a course of events in which Plato infinitely often eats (holds):

\begin{tikzpicture}
  	\begin{axis}[ 
    	xlabel={Number of philosophers},
    	ylabel={Duration (Seconds)}
  	] 
    \addplot+ [color=blue] coordinates {(2, 0.002) (3, 0.002) (4, 0.006) (5, 0.013) (6, 0.047) (7, 0.152) (8, 0.750) (9, 3.079) (10, 12.810) (11, 51.706)}; 
    
    \addplot+ [color=red] coordinates {(2, 0.002) (3, 0.002) (4, 0.002) (5, 0.006) (6, 0.021) (7, 0.097) (8, 0.386) (9, 1.626) (10, 6.633) (11, 27.038)}; 
  	\end{axis}
\end{tikzpicture}

\subsection{Demanding children}
The second experiment is about children that are initially playing. A child can ask a question, get the answer and return to playing (in that order). Only for one child the actions are named, this child will simply be referred to as 'the child'. For this experiment four mu-calculus formulas were made which are elaborated on below. Afterwards the results of this experiment are given.

\subsubsection{Mu-calculus formulas}
\textbf{It is possible for the child to never ask a question}\\
This can be expressed with the formula:\\
{\tt nu X. ([i]X \&\& nu Y. <i>Y)}\\
The part {\tt nu X. ([i]X ..)} iterates over all successor states as long as the child does nothing, getting to each reachable state where the child has not asked any question. The other part {\tt \&\& nu Y. <i>Y} states that from each of these states there must be an infinite sequence of states where the child does nothing (asks no question).\\
The depths of this formula are: $ND = 2$, $AD = 1$ and $DAD = 1$.
\\\\
\textbf{It is possible for all other children to never ask a question}\\
This can be expressed with the formula:\\
{\tt nu X. ((([ask]X \&\& [wisdom]X) \&\& [playing]X) \&\& nu Y. ((<ask>Y || <wisdom>Y) || <playing>Y))}\\
The part {\tt nu X. ((([ask]X \&\& [wisdom]X) \&\& [playing]X)} iterates over all successor states as long as the other children than the child do nothing, getting to each reachable state where the other children than the child have not asked any question. The other part {\tt \&\& nu Y. ((<ask>Y || <wisdom>Y) || <playing>Y)} states that from each of these states there must be an infinite sequence of states where the other children than the child do nothing (ask no question).\\ 
The depths of this formula are: $ND = 2$, $AD = 1$ and $DAD = 1$.
\\\\
\textbf{If the child asks a question the child will eventually be answered}\\
This can be expressed with the formula:\\
{\tt nu X. (((([i]X \&\& [ask]X) \&\& [wisdom]X) \&\& [playing]X) \&\& mu Y. (((<i>Y || <ask>Y) || <playing>Y) || <wisdom>true))}\\
The part {\tt nu X. (((([i]X \&\& [ask]X) \&\& [wisdom]X) \&\& [playing]X) ..)} iterates over all successor states, getting to each reachable state. The other part states that from each of these states there must be finite sequence of states where the child is not answered ({\tt mu Y. (((<i>Y || <ask>Y) || <playing>Y) ..)}) after which the child gets answered ({\tt  || <wisdom>true}). Note that it is not necessary to check whether the child has asked a question before the child gets answered, since this is enforced by the LTS.\\
The depths of this formula are: $ND = 2$, $AD = 2$ and $DAD = 1$.
\\\\
\textbf{There is a course of events where the child can ask an infinite number of questions}\\
This can be expressed with the formula:\\
{\tt nu X. mu Y. (((<ask>X || <i>Y) || <wisdom>Y) || <playing>Y)}\\
The part {\tt mu Y. (((<ask>X || <i>Y) || <wisdom>Y) || <playing>Y)} states that er must be a finite sequence of states where the child does not ask a question, after which the child will be able to ask a question. The part {\tt nu X. .. (((<ask>X ..) ..) ..)} states that this sequence must be able to repeat itself infinitely often.\\
The depths of this formula are: $ND = 2$, $AD = 2$ and $DAD = 2$.

\subsubsection{Solver and performance results}


\subsection{Boardgame}
The third and last experiment is about two players playing a board game. The game is played on a $N$ by $N$ board and they start at state $(0, 0)$. Each player alternatively can choose to make a move, starting with player I. Player II wins whenever the game reaches state $(N, N)$. In the LTS being in the state $(N, N)$ is denoted by being able to do the transition {\tt won}. For this experiment three mu-calculus formulas are made which are elaborated on below. Afterwards the results of this experiment are given.

\subsubsection{Mu-calculus formulas}
\textbf{3a: There is a play such that player II can win}\\
This can be expressed with the formula:\\
{\tt mu X. (<choose1><choose2>X || <won>true)}\\
This formula states that there must be a finite sequence of states in which first player I makes a choice and then player II ({\tt mu X. (<choose1><choose2>X ..)}) after which the game will end up in state $(N, N)$, causing player II to win ({\tt || <won>true}).\\
The depths of this formula are: $ND = 1$, $AD = 1$ and $DAD = 1$.
\\\\
\textbf{3b: Player II wins the game}\\
This can be expressed with the formula:\\
{\tt mu X. ([choose1]<choose2>X || <won>true)}\\
This formula states that whatever move player I chooses ({\tt [choose1]}) player II can choose a move (player II has a strategy, {\tt <choose2>}) such that the game will have a finite sequence of states ({\tt mu X. ([choose1]<choose2>X ..)}) such that the game ends up in state $(N, N)$, causing player II to win ({\tt || <won>true}).\\
The depths of this formula are: $ND = 1$, $AD = 1$ and $DAD = 1$.
\\\\
\textbf{3c: Player II wins the game by being able to move the token to place (N, N) infinitely often}\\
This can be expressed with the formula:\\
{\tt nu Y. mu X. ([choose1]<choose2>X || ([choose1]<choose2><won>true \&\& [choose1]<choose2>Y))}\\
The part {\tt mu X. ([choose1]<choose2>X ..)} states that there must be a finite sequence of states in which player I chooses any step and player II does a certain step (according to a strategy). The other part says that after this finite sequence player II will be able to move to state $(N, N)$ within a turn independent of what player I does ({\tt || ([choose1]<choose2><won>true ..)}) and after one turn it is possible to repeat this sequence ({\tt nu Y. .. (.. (.. \&\& [choose1]<choose2>Y))}), causing the game to get to state $(N, N)$ infinitely often, causing player II to win.\\
The depths of this formula are: $ND = 2$, $AD = 2$ and $DAD = 2$.

\subsubsection{Solver and performance results}


\section{Conclusion}\label{conc}


\begin{thebibliography}{9}

\bibitem{muparse} http://www.win.tue.nl/\~timw/downloads/parser.pdf

\end{thebibliography}


\begin{comment}
A picture of the labelled transition system.

\begin{tikzpicture}[->,>=stealth', shorten >=1pt,auto, node distance=2.8cm, semithick]
  \tikzstyle{every state}=[text=black]

  \node[initial,state] (0)                    {$0$};
  \node[state]         (1) [right of=0] {$1$};
  \node[state]         (2) [below of=0] {$2$};
  \node[state]         (3) [right of=1] {$3$};
  \node[state]         (4) [below of=1] {$4$};
  \node[state]         (5) [below of=2] {$5$};
  \node[state]         (6) [right of=4] {$6$};
  \node[state]         (7) [below of=4] {$7$};
  
 \path (0) edge node {$\tau$} (1)
 	   (0) edge node {$\tau$} (2)
 	   (1) edge node {$\tau$} (3)
 	   (1) edge node {$\tau$} (4)
 	   (2) edge node {$\tau$} (5)
 	   (2) edge node {$\tau$} (4)
 	   (3) edge node {$a$} 	  (6)
 	   (3) edge [bend right] node {$b$} 	  (0)
 	   (4) edge node {$\tau$} (6)
 	   (4) edge node {$\tau$} (7)
 	   (5) edge [bend left] node {$a$}    (0)
 	   (5) edge node {$a$}    (7)
 	   (6) edge [bend right] node {$\tau$} (2)
 	   (7) edge [bend right] node {$b$}    (1);
\end{tikzpicture}
\end{comment}
\end{document}